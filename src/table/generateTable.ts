import fs = require("fs");
import path = require("path");
import { v4 as uuidv4 } from "uuid";
import logger from "../utils/logger";

// Mongoose Schema
import { NebulaVideo } from "../models/nebulaVideo/nebulaVideo";
import { YoutubeVideo } from "../models/youtubeVideo/youtubeVideo";
import { youtubeIds } from "../utils/youtubeIds";
import { Channel } from "../models/channel/channel";

/**
 * @type {Object} MatchedVideo
 * @description A matched video object that includes the Nebula video and the Youtube video
 * @property {string} id - The youtube id of the video
 * @property {string} nebulaId - The nebula id of the video
 */
export type MatchedVideo = {
  id: string; // Short youtube id
  slug: string; // Nebula slug
};

/**
 * @type {Object} ChannelEntry
 * @property {string} slug - The channel slug of the channel that the videos belong to
 * @property {string} youtubeId - The youtube id of the channel
 * @property {string} custom_url - The custom url of the channel
 * @property {string[]} matched - A list of youtube video ids that have been matched to a nebula video
 * @property {string[]} not_matched - A list of youtube video ids that have not been matched to a nebula video
 */
export interface ChannelEntry {
  slug: string;
  custom_url: string;
  youtubeId: string;
  matched: MatchedVideo[];
  not_matched: string[];
}

/**
 * @type {Object} LookupTable
 * @description A lookup table that maps youtube video ids to nebula video ids for each known channel. This table is generated by the server and is sent to the client to lookup videos before requesting a redirect from the server.
 * @property {string} generatedAt - The date the lookup table was generated
 * @property {ChannelEntry[]} channels - A list of channel entries {@link ChannelEntry}
 * @property {string} id - The id of the lookup table
 */
export interface LookupTable {
  channels: ChannelEntry[];
  generatedAt: string;
  id: string;
}

/**
 * @function generateTable
 * @description Generates a lookup table that maps youtube video ids to nebula video ids for each known channel. This table is generated by the server and is sent to the client to lookup videos before requesting a redirect from the server.
 * @param {number} maximumMatchDistance - The maximum distance between a youtube video and a nebula video to be considered a match. Lower is more strict.
 * @returns {Promise<LookupTable>} A lookup table
 * @throws {Error} If the lookup table cannot be generated

 * @async
 */

export const generateTable = async (
  maximumMatchDistance?: number
): Promise<LookupTable> => {
  try {
    console.time("generateTable");
    const matchLimit = maximumMatchDistance || 2;

    // Get all the nebula videos that are matched
    const nebulaVideos = await NebulaVideo.find({
      youtubeVideoId: { $exists: true },
      matchStrength: { $lte: matchLimit },
    })
      .select("youtubeVideoObjectId channelSlug slug")
      .lean();
    logger.debug(
      `generateTable: Found ${nebulaVideos.length} matched nebula videos`
    );

    // Get all the youtube videos that are matched
    const youtubeVideos = await YoutubeVideo.find({})
      .select("youtubeVideoId channelSlug")
      .lean();
    logger.debug(`generateTable: Found ${youtubeVideos.length} youtube videos`);

    // Create a lookup table
    const lookupTable: LookupTable = {
      channels: [],
      generatedAt: new Date().toISOString(),
      id: uuidv4(),
    };

    const channels = await Channel.find({}).select("slug custom_url");

    // Create a channel entry for each channel using promise.allSettled
    const channelPromises = youtubeIds.map(async (channel) => {
      return new Promise<ChannelEntry>((resolve, reject) => {
        try {
          // 4.1
          // Create a channel entry
          const channelSlug = channel.slug;
          const channelEntry: ChannelEntry = {
            slug: channelSlug,
            custom_url:
              channels.find((c) => c.slug === channelSlug)?.custom_url || "",
            youtubeId: channel.youtubeId,
            matched: [],
            not_matched: [],
          };

          // 4.2
          // Get all the youtube videos for the channel
          const channelYoutubeVideos = youtubeVideos.filter(
            (video) => video.channelSlug === channelSlug
          );

          // 4.3
          // Get all the nebula videos for the channel
          const channelNebulaVideos = nebulaVideos.filter(
            (video) => video.channelSlug === channelSlug
          );

          // 4.4
          // Create a matched video entry for each matched video
          channelYoutubeVideos.forEach((youtubeVideo) => {
            const matchedNebulaVideo = channelNebulaVideos.find(
              (nebulaVideo) =>
                nebulaVideo.youtubeVideoObjectId?.toString() ===
                youtubeVideo._id.toString()
            );

            if (matchedNebulaVideo) {
              channelEntry.matched.push({
                id: youtubeVideo.youtubeVideoId,
                slug: matchedNebulaVideo.slug,
              });
            } else {
              // 4.5
              // Add the youtube video id to the not matched list
              channelEntry.not_matched.push(youtubeVideo.youtubeVideoId);
            }
          });

          // 4.6
          // Resolve the channel entry
          resolve(channelEntry);
        } catch (error) {
          reject(error);
        }
      });
    });

    // 5.
    // Wait for all the channel entries to be created
    console.time("generateTable: Promise.allSettled");
    const channelEntries = await Promise.allSettled(channelPromises)
      .then((results) => {
        return results.map((result) => {
          if (result.status === "fulfilled") {
            return result.value;
          } else {
            logger.error(`generateTable: promise error: ${result.reason}`);
            return null;
          }
        });
      })
      .catch((error) => {
        logger.error(`generateTable: Cleaning up channel entries: ${error}`);
        throw error;
      });
    console.timeEnd("generateTable: Promise.allSettled");

    // 6.
    // Add the channel entries to the lookup table
    channelEntries.forEach((channelEntry) => {
      if (channelEntry) {
        lookupTable.channels.push(channelEntry);
      }
    });

    // 7.
    // Check that the lookup table has been generated correctly
    const totalMatched = lookupTable.channels.reduce(
      (total, channel) => total + channel.matched.length,
      0
    );
    const totalNotMatched = lookupTable.channels.reduce(
      (total, channel) => total + channel.not_matched.length,
      0
    );
    logger.debug(
      `generateTable: Generated lookup table with ${totalMatched} matched and ${totalNotMatched} not matched`
    );

    // 8.
    // Save the lookup table to the json file
    logger.debug(`generateTable: Saving lookup table`);
    await fs.promises.writeFile(
      path.join(__dirname, "/lookup_table.json"),
      JSON.stringify(lookupTable),
      "utf-8"
    );

    console.timeEnd("generateTable");

    // 9.
    // Return the lookup table
    return lookupTable;
  } catch (error) {
    logger.error(`generateTable: ${error}`);
    throw error;
  }
};

export default generateTable;
