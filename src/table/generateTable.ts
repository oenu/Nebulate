import fs = require("fs");
import path = require("path");
import { v4 as uuidv4 } from "uuid";
import logger from "../utils/logger";

// Mongoose Schema
import { NebulaVideo } from "../models/nebulaVideo/nebulaVideo";
import { YoutubeVideo } from "../models/youtubeVideo/youtubeVideo";

/**
 * @type {Object} MatchedVideo
 * @description A matched video object that includes the Nebula video and the Youtube video
 * @property {string} id - The youtube id of the video
 * @property {string} nebulaId - The nebula id of the video
 */
export type MatchedVideo = {
  id: string; // Short youtube id
  slug: string; // Nebula slug
};

/**
 * @type {Object} ChannelEntry
 * @property {string[]} matched - A list of youtube video ids that have been matched to a nebula video
 * @property {string[]} not_matched - A list of youtube video ids that have not been matched to a nebula video
 * @property {string} slug - The channel slug of the channel that the videos belong to
 */
export interface ChannelEntry {
  matched: MatchedVideo[];
  not_matched: string[];
  slug: string;
}

/**
 * @type {Object} LookupTable
 * @description A lookup table that maps youtube video ids to nebula video ids for each known channel. This table is generated by the server and is sent to the client to lookup videos before requesting a redirect from the server.
 * @property {string} generatedAt - The date the lookup table was generated
 * @property {ChannelEntry[]} channels - A list of channel entries {@link ChannelEntry}
 * @property {string} id - The id of the lookup table
 */
export interface LookupTable {
  channels: ChannelEntry[];
  generatedAt: Date;
  id: string;
}

/**
 * @function generateTable
 * @description Generates a lookup table that maps youtube video ids to nebula video ids for each known channel. This table is generated by the server and is sent to the client to lookup videos before requesting a redirect from the server.
 * @param {number} maximumMatchDistance - The maximum distance between a youtube video and a nebula video to be considered a match. Lower is more strict.
 * @returns {Promise<LookupTable>} A lookup table
 * @throws {Error} If the lookup table cannot be generated

 * @async
 */

// rewrite the following to be more clear and efficient

export const generateTable = async (maximumMatchDistance?: number) => {
  const matchLimit = maximumMatchDistance || 2;

  // Find all the nebula videos in the database
  const nebulaVideos = await NebulaVideo.find({
    youtubeVideoId: { $exists: true },
    matchStrength: { $lte: matchLimit },
  })
    .select("youtubeVideoObjectId channelSlug slug")
    .lean();

  logger.debug(
    `generateTable: Found ${nebulaVideos.length} matched nebula videos`
  );
  // Find all youtube videos in the database
  const youtubeVideos = await YoutubeVideo.find({})
    .select("youtubeVideoId channelSlug")
    .lean();
  logger.debug(`generateTable: Found ${youtubeVideos.length} youtube videos`);

  // Get a list of all the channels that have youtube videos in the database
  const channelSlugs = [...new Set(nebulaVideos.map((v) => v.channelSlug))];
  logger.debug(`generateTable: Found ${channelSlugs.length} channels`);

  // Create a channel entry for each channel
  const channelEntries: ChannelEntry[] = channelSlugs.map((slug) => {
    return {
      matched: [],
      not_matched: [],
      slug,
    };
  });

  // For each youtube video, find the matching nebula video and add it to the channel entry
  youtubeVideos.forEach((youtubeVideo) => {
    // Find the channel for the youtube video
    const channelEntry = channelEntries.find(
      (entry) => entry.slug === youtubeVideo.channelSlug
    );
    if (!channelEntry) {
      logger.error(
        `generateTable: Could not find channel entry for channel ${youtubeVideo.channelSlug}`
      );
      return;
    }

    // Find the matching nebula video for the youtube video
    const nebulaVideo = nebulaVideos.find(
      (video) =>
        video.youtubeVideoObjectId?.toString() === youtubeVideo._id.toString()
    );

    // If there is a matching nebula video, add it to the channel entry as a matched video
    if (nebulaVideo) {
      channelEntry.matched.push({
        id: youtubeVideo.youtubeVideoId,
        slug: nebulaVideo.slug,
      });
    } else {
      // If there is no matching nebula video, add the youtube video id to the channel entry as not matched
      channelEntry.not_matched.push(youtubeVideo.youtubeVideoId);
    }
  });

  // Generate a new id and assign it to the lookup table
  const id = uuidv4();
  const table: LookupTable = {
    generatedAt: new Date(),
    channels: channelEntries,
    id,
  };

  // Write the lookup table to disk
  logger.debug(`generateTable: Saving lookup table`);
  await fs.promises.writeFile(
    path.join(__dirname, "/lookup_table.json"),
    JSON.stringify(table),
    "utf-8"
  );

  logger.info("generateTable: Lookup table generated");
  // Return the lookup table
  return table;
};

export default generateTable;
