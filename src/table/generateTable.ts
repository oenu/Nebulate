import fs = require("fs");
import path = require("path");
import { v4 as uuidv4 } from "uuid";
import logger from "../utils/logger";

// Mongoose Schema
import { NebulaVideo } from "../models/nebulaVideo";
import { YoutubeVideo } from "../models/youtubeVideo";

/**
 * @type {Object} CreatorEntry
 * @property {string[]} matched - A list of youtube video ids that have been matched to a nebula video
 * @property {string[]} not_matched - A list of youtube video ids that have not been matched to a nebula video
 * @property {string} slug - The creator slug of the creator that the videos belong to
 */
interface CreatorEntry {
  matched: string[];
  not_matched: string[];
  slug: string;
}

/**
 * @type {Object} LookupTable
 * @description A lookup table that maps youtube video ids to nebula video ids for each known creator. This table is generated by the server and is sent to the client to lookup videos before requesting a redirect from the server.
 * @property {string} generatedAt - The date the lookup table was generated
 * @property {CreatorEntry[]} creators - A list of creator entries {@link CreatorEntry}
 * @property {string} id - The id of the lookup table
 */
interface LookupTable {
  creators: CreatorEntry[];
  generatedAt: Date;
  id: string;
}

// /**
//  * @function serveLookupTable
//  * @description Serves a lookup table based on age of the lookup table and the version of the lookup table, will regenerate the lookup table if the lookup table is too old
//  * @param {number} maximum_table_age - The maximum age of the lookup table in minutes
//  * @param {string} version - The version of the lookup table to check against, provided by the client on request
//  * @param {number} maximumMatchDistance - The maximum distance between a youtube video and a nebula video to be considered a match. Lower is more strict.
//  * @returns {Promise<LookupTable | true>} A lookup table or true if the lookup table is up to date
//  * @throws {Error} If the lookup table cannot be served
//  * @see {@link generateTable}
//  * @async
//  */

// const serveLookupTable = async (
//   maximum_table_age?: number,
//   version?: string,
//   maximumMatchDistance?: number
// ): Promise<LookupTable | true> => {
//   logger.debug("serveLookupTable: serving lookup table");
//   if (maximum_table_age === undefined) maximum_table_age = 10;

//   // Check how old the lookup table is
//   const lookupTablePath = path.join(__dirname, "/lookup_table.json");
//   const lookupTableExists = await fs.existsSync(lookupTablePath);

//   // If the lookup table doesn't exist, create it
//   if (!lookupTableExists) {
//     logger.warn("serveLookupTable: lookup table does not exist");

//     return await generateTable(maximumMatchDistance);
//   }

//   // Get the age of the lookup table
//   const lookupTable = JSON.parse(fs.readFileSync(lookupTablePath, "utf8"));
//   const lookupTableAge =
//     new Date().getTime() - Date.parse(lookupTable.generatedAt);

//   // If the lookup table is too old, regenerate it and return it
//   if (lookupTableAge > maximum_table_age * 60 * 1000) {
//     logger.warn(
//       `serveLookupTable: Table age: ${Math.round(
//         lookupTableAge / 60 / 1000
//       )} | Max ${maximum_table_age} | regenerate`
//     );
//     return await generateTable(maximumMatchDistance);
//   } else {
//     // If the lookup table is up to date, return it
//     logger.debug(
//       `serveLookupTable: Table age: ${Math.round(
//         lookupTableAge / 60 / 1000
//       )} | Max ${maximum_table_age} | use existing`
//     );

//     // If an id is provided, check if it is different from the current one. This is to reduce the impact on the server.
//     if (version && version == lookupTable.id) {
//       logger.debug(
//         `serveLookupTable: Table version: ${version} | ${lookupTable.id} | table is up to date`
//       );
//       return true;
//     }
//     return lookupTable;
//   }
// };
// export default serveLookupTable;

/**
 * @function generateTable
 * @description Generates a lookup table that maps youtube video ids to nebula video ids for each known creator. This table is generated by the server and is sent to the client to lookup videos before requesting a redirect from the server.
 * @param {number} maximumMatchDistance - The maximum distance between a youtube video and a nebula video to be considered a match. Lower is more strict.
 * @returns {Promise<LookupTable>} A lookup table
 * @throws {Error} If the lookup table cannot be generated
 * @see {@link serveLookupTable}
 * @async
 */

export const generateTable = async (maximumMatchDistance?: number) => {
  const matchLimit = maximumMatchDistance || 2;

  // Find all the nebula videos in the database
  const nebulaVideos = await NebulaVideo.find({
    youtube_video_id: { $exists: true },
    match_strength: { $lte: matchLimit },
  })
    .select("youtube_video_object_id channel_slug")
    .lean();
  logger.debug(
    `serveLookupTable: Found ${nebulaVideos.length} matched nebula videos`
  );
  // Find all youtube videos in the database
  const youtubeVideos = await YoutubeVideo.find({})
    .select("youtube_video_id channel_slug")
    .lean();
  logger.debug(
    `serveLookupTable: Found ${youtubeVideos.length} youtube videos`
  );

  // Get a list of all the creators that have youtube videos in the database
  const creatorSlugs = [...new Set(nebulaVideos.map((v) => v.channel_slug))];
  logger.debug(`serveLookupTable: Found ${creatorSlugs.length} creators`);

  // Create a useful data structure for the lookup table, with a list of youtube video ids for each creator
  const videoEntries = youtubeVideos.map((youtubeVideo) => {
    return {
      url: youtubeVideo.youtube_video_id,
      slug: youtubeVideo.channel_slug,
      matched: nebulaVideos.some((nebulaVideo) => {
        return nebulaVideo.youtube_video_object_id
          ? nebulaVideo.youtube_video_object_id.toString() ===
              youtubeVideo._id.toString()
          : false;
      }),
    };
  });

  // Compress the data structure into a lookup table
  const lookup_prototype = {
    generatedAt: new Date(),
    creators: creatorSlugs.map<CreatorEntry>((creatorSlug) => {
      const creatorVideos = videoEntries.filter((v) => v.slug === creatorSlug);
      const matched = creatorVideos.filter((v) => v.matched);
      const notMatched = creatorVideos.filter((v) => !v.matched);
      return {
        matched: matched.map((v) => v.url),
        not_matched: notMatched.map((v) => v.url),
        slug: creatorSlug,
      };
    }),
  };

  // Generate a new id and assign it to the lookup table
  const id = uuidv4();
  const table: LookupTable = {
    ...lookup_prototype,
    id,
  };

  // Write the lookup table to disk
  logger.debug(`serveLookupTable: Saving lookup table`);
  await fs.promises.writeFile(
    path.join(__dirname, "/lookup_table.json"),
    JSON.stringify(table),
    "utf-8"
  );

  // Return the lookup table
  return table;
};
